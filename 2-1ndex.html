<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쪼개기 마스터 v1.2 (성장 리포트)</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-color: #4A80F3;
            --text-color: #333333;
            --light-bg-color: #f9f9f9;
            --border-color: #e0e0e0;
            --success-color: #28a745;
            --warning-color: #fd7e14; /* 주황색 계열 */
            --danger-color: #dc3545; /* 빨간색 계열 */
            --white-color: #FFFFFF;
            --font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, "Helvetica Neue", "Segoe UI", "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--white-color);
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

       .container {
            width: 100%;
            max-width: 800px;
            padding: 40px 20px;
            box-sizing: border-box;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        header h1 {
            font-size: 36px;
            font-weight: 800;
            margin: 0;
            color: var(--primary-color);
        }

        header p {
            font-size: 18px;
            color: #666;
            margin-top: 8px;
        }

        /* --- [NEW] 오류 배너 스타일 --- */
        #error-banner {
            background-color: var(--danger-color);
            color: var(--white-color);
            padding: 16px 24px;
            border-radius: 8px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }
        #error-message {
            font-weight: 600;
            margin: 0;
        }
        #error-close {
            background: none;
            border: none;
            color: var(--white-color);
            font-size: 24px;
            font-weight: 700;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        #error-close:hover {
            opacity: 1;
        }
        /* --- [END] 오류 배너 스타일 --- */


       .main-card {
            background-color: var(--white-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            margin-bottom: 24px;
        }

        /* 입력 섹션 스타일 */
        #input-section h2, #analysis-section h2, #feedback-report-section h2 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border-color);
        }
         #input-section h2:first-of-type { margin-top: 0; }


        #text-input {
            width: 100%;
            height: 200px;
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 16px;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 8px; /* 카운터 공간 */
        }

        /* --- [NEW] 글자 수 카운터 스타일 --- */
        #char-counter {
            text-align: right;
            font-size: 14px;
            font-weight: 500;
            color: var(--danger-color); /* 기본값 (부족) */
        }
        #char-counter.sufficient {
            color: var(--success-color); /* 충족 시 */
            font-weight: 600;
        }
        /* --- [END] 글자 수 카운터 스타일 --- */


       .course-options {
            margin-top: 24px;
            display: flex;
            gap: 16px;
        }

       .course-option {
            flex: 1;
            padding: 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

       .course-option:hover,.course-option.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(74, 128, 243, 0.2);
        }

       .course-option h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
        }

       .course-option p {
            margin: 0;
            font-size: 14px;
            color: #666;
        }

       .btn {
            display: block;
            width: 100%;
            padding: 16px;
            margin-top: 24px;
            background-color: var(--primary-color);
            color: var(--white-color);
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease;
            box-sizing: border-box; /* 너비 계산에 패딩 포함 */
        }
       .btn-secondary { /* 새로운 훈련 시작 버튼 */
            background-color: #6c757d; /* 회색 계열 */
            margin-top: 32px;
       }
       .btn-secondary:hover {
             background-color: #5a6268;
       }

       .btn:hover {
            background-color: #3a6cc7;
        }

       .btn:disabled {
            background-color: #a0b9e8;
            cursor: not-allowed;
        }

        /* 분석 섹션 스타일 */
        #analysis-section {
            /* display: none; ⬅️ 이 코드를 삭제했음. */
        }
         #analysis-section h2 { text-align: center; margin-bottom: 12px; } /* 마진 조정 */

        /* --- [NEW] 진행률 표시기 스타일 --- */
        #progress-indicator {
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: var(--primary-color);
            margin: -8px 0 24px 0; /* h2와 카드 사이 */
        }
        /* --- [END] 진행률 표시기 스타일 --- */


       .chunk-card {
            background: var(--white-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 24px;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr 1.5fr; /* 좌우 분할 레이아웃 */
            gap: 24px;
        }

       .original-text-container {
            background-color: var(--light-bg-color);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

       .original-text-container h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #555;
            display: flex; align-items: center; gap: 6px;
       }
       .original-text-container h4::before { /* 아이콘 예시 */
             content: '📄';
       }


        p.original-text {
            font-size: 16px;
            line-height: 1.7;
            margin: 0;
            word-break: keep-all;
        }

       .analysis-input-container h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--primary-color);
             display: flex; align-items: center; gap: 6px;
       }
        .analysis-input-container h4::before { /* 아이콘 예시 */
             content: '✍️';
        }


        textarea.analysis-input {
            width: 100%;
            height: 150px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 15px;
            resize: vertical;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s; /* 포커스 효과 */
        }
        textarea.analysis-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(74, 128, 243, 0.2);
            outline: none;
        }
        /* 입력 누락 시 스타일 (JS로 제어) */
        textarea.analysis-input.invalid {
            border: 1px solid var(--danger-color);
            box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2);
        }


        /* 성장 리포트 섹션 스타일 */
        #feedback-report-section {
            width: 100%;
            max-width: 800px; /* container와 동일 너비 */
            padding: 0; /* 내부에서 패딩 관리 */
            box-sizing: border-box;
            animation: fadeIn 0.5s ease-out;
        }

        .report-header {
            text-align: center;
            padding: 32px;
            border-radius: 12px 12px 0 0;
            margin-bottom: 0; /* main-card와 붙이기 */
        }
        .report-header h2 {
            font-size: 28px;
            margin: 0 0 8px 0;
            color: var(--primary-color);
            border-bottom: none; /* 헤더 제목에는 밑줄 제거 */
        }


        #feedback-score-container {
            text-align: center;
        }

        #feedback-score {
            font-size: 96px; /* 더 크게 */
            font-weight: 900;
            margin: 0; /* 위아래 마진 제거 */
            line-height: 1; /* 줄 간격 타이트하게 */
        }

       /* 점수별 색상 */
       .score-s { color: var(--success-color); } /* 85+ */
       .score-a { color: var(--primary-color); } /* 60-84 */
       .score-b { color: var(--warning-color); } /* 40-59 */
       .score-c { color: var(--danger-color); }  /* 0-39 */


        #feedback-summary {
            font-size: 22px; /* 약간 크게 */
            font-weight: 600;
            margin-top: 8px; /* 점수와 약간 간격 */
            margin-bottom: 32px;
            color: #555;
        }

        /* 레이더 차트 컨테이너 */
        #chart-container {
             width: 100%;
             max-width: 400px; /* 차트 크기 조절 */
             margin: 0 auto 32px auto; /* 중앙 정렬 및 아래 간격 */
             padding: 24px;
             background-color: var(--light-bg-color);
             border-radius: 8px;
        }

       .feedback-details {
            display: grid; /* Flex 대신 Grid 사용 */
            grid-template-columns: 1fr 1fr; /* 좌우 2단 */
            gap: 24px;
            text-align: left;
            margin-bottom: 32px;
        }

       .feedback-panel {
            /* flex: 1; 제거 */
            background-color: var(--light-bg-color);
            border-radius: 8px;
            padding: 24px; /* 패딩 증가 */
        }

       .feedback-panel h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700; /* 제목 강조 */
       }

        #good-points-panel h3 { color: var(--success-color); }
        #improvement-points-panel h3 { color: var(--warning-color); }

       .feedback-panel ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

       .feedback-panel li {
            margin-bottom: 12px;
            font-size: 15px;
            line-height: 1.7;
            padding-left: 20px; /* 아이콘 공간 */
            position: relative;
       }
        /* 리스트 아이템 앞에 아이콘 추가 */
       #good-points-panel li::before {
           content: '👍';
           position: absolute; left: 0;
       }
        #improvement-points-panel li::before {
           content: '📈';
           position: absolute; left: 0;
       }

        /* 액션 플랜 및 셀프 코칭 */
        .action-plan-section, .self-coaching-section {
            background-color: var(--white-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
        }
         .action-plan-section h3, .self-coaching-section h3 {
             font-size: 18px;
             font-weight: 700;
             margin: 0 0 16px 0;
             display: flex; align-items: center; gap: 8px;
             color: var(--primary-color);
         }
        .action-plan-section h3::before { content: '🎯'; }
        .self-coaching-section h3::before { content: '🤔'; }

         .action-plan-section p, .self-coaching-section p {
             font-size: 16px;
             line-height: 1.7;
             margin: 0;
             color: #555;
         }
         .self-coaching-section ul {
            list-style-type: none; padding: 0; margin-top: 12px;
         }
         .self-coaching-section li {
             margin-bottom: 8px; font-size: 15px; color: #555;
             padding-left: 20px; position: relative;
         }
         .self-coaching-section li::before {
              content: '❓'; position: absolute; left: 0;
         }


       /* --- [DELETED] 스켈레톤 로더 스타일 --- */
       /*
        .skeleton-box { ... }
        #analysis-skeleton .chunk-card-skeleton { ... }
        #feedback-skeleton .score-skeleton { ... }
        ...
        */


        /* --- [NEW] 동적 로더 스타일 --- */
        #dynamic-loader {
            text-align: center;
            padding: 48px;
            align-items: center;
            justify-content: center;
            /* display: flex;가 JS의 .hidden을 이기므로, JS로 제어합니다. */
            flex-direction: column;
            gap: 24px;
        }
        .spinner {
            border: 6px solid #f3f3f3; /* Light grey */
            border-top: 6px solid var(--primary-color); /* Blue */
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        #loader-text {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }
        /* --- [END] 동적 로더 스타일 --- */


        footer {
            text-align: center;
            padding: 20px;
            font-size: 14px;
            color: #999;
            margin-top: 40px; /* 리포트와 푸터 간격 */
        }

        .hidden { display: none !important; } /* 확실히 숨김 */

        /* --- [MODIFIED] spin 애니메이션 추가 --- */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes skeleton-shine {
            0% { left: -150%; }
            100% { left: 150%; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* 모바일 반응형 */
        @media (max-width: 768px) {
           .container { padding: 20px 15px; }
           header h1 { font-size: 28px; }
           header p { font-size: 16px; }
           .main-card, .chunk-card, .feedback-panel, .action-plan-section, .self-coaching-section { padding: 20px; }
           #text-input { height: 150px; }
           .course-options {
               flex-direction: column; /* 3개여도 세로 정렬 */
           }
           .chunk-card {
                grid-template-columns: 1fr; /* 모바일에서는 세로 정렬 */
           }
           #feedback-score { font-size: 72px; }
           #feedback-summary { font-size: 18px; }
           .feedback-details {
                grid-template-columns: 1fr; /* 모바일에서는 세로 정렬 */
           }
           /* --- [DELETED] 스켈레톤 모바일 --- */
           /*
           #feedback-skeleton .details-skeleton {
                grid-template-columns: 1fr;
           }
           */
        }

    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>쪼개기 마스터</h1>
            <p>매일 한 문장씩 쪼개고, 컨텐츠 마스터가 되세요.</p>
        </header>

        <div id="error-banner" class="hidden">
            <p id="error-message">오류가 발생했습니다.</p>
            <button id="error-close" type="button" aria-label="닫기">&times;</button>
        </div>

        <div id="dynamic-loader" class="main-card hidden">
            <div class="spinner"></div>
            <p id="loader-text">분석 중입니다...</p>
        </div>


        <div class="main-card" id="input-section">
            <h2>1. 분석할 텍스트 입력</h2>
            <textarea id="text-input" placeholder="분석하고 싶은 블로그 글, 영상 대본, 카피 등을 여기에 붙여넣으세요. (50자 이상)"></textarea>
            <div id="char-counter">0 / 50자</div>

            <h2 style="margin-top: 32px;">2. 훈련 코스 선택</h2>
            <div class="course-options">
                <div class="course-option" data-course="quick">
                    <h3>Quick Course</h3>
                    <p>핵심 의미 5개 쪼개기<br>(전략적 핵심 점검)</p>
                </div>
                <div class="course-option" data-course="medium">
                    <h3>Medium Course</h3>
                    <p>주요 의미 10개 쪼개기<br>(핵심 논리 집중 훈련)</p>
                </div>
                <div class="course-option" data-course="full">
                    <h3>Full Course</h3>
                    <p>전체 텍스트 쪼개기<br>(심층 집중 훈련)</p>
                </div>
            </div>

            <button id="start-split-button" class="btn" disabled>쪼개기 훈련 시작</button>
        </div>

        <div id="analysis-section" class="hidden">
            <h2 style="text-align: center; margin-bottom: 12px;">3. 사고 과정 분석</h2>
            <p id="progress-indicator">0 / 0 항목 분석 완료</p>
            <div id="analysis-inputs">
                </div>
            <button id="get-feedback-button" class="btn">분석 완료 & 성장 리포트 보기</button>
        </div>

        <div id="feedback-report-section" class="hidden">
            <div class="main-card report-header">
                <h2>📊 성장 리포트</h2>
                 <div id="feedback-score-container">
                    <p style="font-size: 18px; font-weight: 600; color: #555; margin: 0;">당신의 쪼개기 실력은...</p>
                    <div id="feedback-score"></div>
                    <p id="feedback-summary"></p>
                 </div>
            </div>

             <div class="main-card">
                 <h2>📈 4대 기준 평가</h2>
                 <div id="chart-container">
                     <canvas id="feedback-radar-chart"></canvas>
                 </div>

                 <div class="feedback-details">
                    <div class="feedback-panel" id="good-points-panel">
                        <h3>잘한 점</h3>
                        <ul id="good-points-list"></ul>
                    </div>
                    <div class="feedback-panel" id="improvement-points-panel">
                        <h3>개선할 점</h3>
                        <ul id="improvement-points-list"></ul>
                    </div>
                 </div>
            </div>

             <div class="action-plan-section">
                 <h3>다음 훈련 목표 제안</h3>
                 <p id="action-plan-text"></p>
             </div>

             <div class="self-coaching-section">
                 <h3>스스로에게 질문해보세요</h3>
                 <ul>
                    <li>오늘 받은 피드백 중 가장 개선이 시급한 부분은 무엇인가?</li>
                    <li>이 피드백을 내일 작성할 OOO 콘텐츠에 어떻게 적용할 수 있을까?</li>
                    <li>쪼개기 실력 향상을 위해 추가적으로 어떤 노력을 할 수 있을까?</li>
                 </ul>
             </div>

             <button id="reset-button" class="btn btn-secondary">새로운 훈련 시작</button>
        </div>

        </div> <footer>
        <p>© 2025 Jjokegi Master. 이상한마케팅 구성원 분들을 위해 만들어졌습니다.</p>
    </footer>

    <script>
        // --- [START] REAL AI CONFIGURATION ---
        const GEMINI_API_KEY = "AIzaSyCVTLte-n_F-83vTq3P1Fc16NzGXdKaIYI";
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_API_KEY}`;
        // --- [END] REAL AI CONFIGURATION ---


        // --- S-Class AI Prompts ---
        // --- [START] 수정된 부분 : 쪼개기 순서 오류 수정 ---
        const SPLIT_PROMPT = (text, mode) => {
            const coreInstruction = `
                You are an expert in Jacheong's 'Jjokegi Theory'. Your task is to analyze the *entire* text provided below to find the 'Minimum Viable Meaning Units' (최소 의미 단위) that a master marketer would identify.
                A 'Minimum Viable Meaning Unit' is an individual claim, psychological hook, setup/payoff pair, problem-solution statement, or distinct persuasive argument. A single sentence may contain multiple meaning units.
            `;

            const modeInstruction = mode === 'quick'
               ? "After analyzing the *entire* text, extract *only* the 5 *most strategically important* meaning units from anywhere in the text. Do not just take the first 5."
               : (mode === 'medium'
                    ? "After analyzing the *entire* text, extract *only* the 10 *most strategically important* meaning units from anywhere in the text. Do not just take the first 10."
                    : "Deconstruct the *entire* text into *all* its meaning units, in the order they appear.");

            const outputInstruction = "Your output MUST be a JSON array of strings, with no other text, commentary, or explanation.";

            return `${coreInstruction}\n\n${modeInstruction}\n\n${outputInstruction}\n\nText to analyze:\n"""${text}"""\n\nOutput only the JSON array.`;
        };
        // --- [END] 수정된 부분 ---

        const FEEDBACK_PROMPT = (userAnalyses) => {
            // ***** KOREAN FEEDBACK & ENHANCED JSON MODIFICATION *****
            return `
                You are an S-Class Senior Marketer at 'Isanghan Marketing'. You have completely internalized the philosophies of Jacheong. Your feedback must be mercilessly sharp, logical, and strategic, but ultimately constructive, aimed at fostering rapid growth in a junior marketer. Do not be polite or vague. Be direct and analytical. **Crucially, all feedback text (good_points, improvement_points, action_plan) MUST be written in KOREAN and MUST NOT contain any markdown formatting (\`**\`, \`\`\` etc.). Use plain text only.**

                Your sole mission is to evaluate the user's submitted 'thought process' for each text chunk based on the quality and depth of their strategic reasoning.

                **[START OF MODIFICATION]**
                **특히 다음 기준을 중점적으로 평가하세요:**

                1.  **[본능 분석]** 사용자의 분석이 고객의 핵심적인 '본능(두려움, 욕망, LF8)'을 정확히 포착했는가?
                2.  **[반박 제거]** 해당 문장이 고객의 예상 '반박'을 얼마나 효과적으로 선제 제거하거나 해소하는 논리를 가졌는가?
                3.  **[고객 성공 기여도]** 사용자의 분석이, 해당 문장이 **궁극적인 '고객 성공'(예: 신뢰 형성, 다음 단계로의 행동 유도, 구매 결정 촉진 등)**에 어떻게 기여하는지를 명확히 설명하고 있는가? (단순히 기술적 분석에 그치지 않고, 최종 목표와의 연결성을 평가)
                4.  **[심리학/가치 증명]** 사용된 심리학적 원리나 가치 증명 방식이 명확하고 설득력 있는가?
                **[END OF MODIFICATION]**

                Provide your response in a strict JSON format with five keys:
                1.  "score": An integer from 0 to 100 representing the overall quality of the user's thought process.
                2.  "criteria_scores": An object containing integer scores (0-100) for EACH of the 4 criteria above (keys: "instinct", "rebuttal", "psychology", "customer_success"). Base these scores on your evaluation.
                3.  "good_points": An array of strings detailing what the user did well **in KOREAN plain text**, referencing the criteria.
                4.  "improvement_points": An array of strings with actionable advice on what to improve **in KOREAN plain text**, referencing the criteria.
                5.  "action_plan": A single string containing a concise (1-2 sentences) recommended next training goal **in KOREAN plain text**, based on the biggest area for improvement.

                Do not add any other text, commentary, or markdown formatting. Just the raw JSON object.

                User's Analyses to evaluate:
                ${JSON.stringify(userAnalyses, null, 2)}
            `;
            // ***** END OF MODIFICATION *****
        };

        // --- DOM Elements ---
        const inputSection = document.getElementById('input-section');
        const analysisSection = document.getElementById('analysis-section');
        const feedbackReportSection = document.getElementById('feedback-report-section');
        // --- [DELETED] loader ---
        // const loader = document.getElementById('loader');

        // --- [MODIFIED] 스켈레톤 -> 동적 로더 및 오류 배너 ---
        const errorBanner = document.getElementById('error-banner');
        const errorMessage = document.getElementById('error-message');
        const errorClose = document.getElementById('error-close');
        // --- [DELETED] analysisSkeleton, feedbackSkeleton ---
        // const analysisSkeleton = document.getElementById('analysis-skeleton');
        // const feedbackSkeleton = document.getElementById('feedback-skeleton');
        const dynamicLoader = document.getElementById('dynamic-loader'); // [NEW]
        const loaderText = document.getElementById('loader-text'); // [NEW]

        const textInput = document.getElementById('text-input');
        const charCounter = document.getElementById('char-counter'); // [NEW]
        const courseOptionsContainer = document.querySelector('.course-options');
        const courseOptions = document.querySelectorAll('.course-option');
        const startSplitButton = document.getElementById('start-split-button');
        const analysisInputsContainer = document.getElementById('analysis-inputs');
        const progressIndicator = document.getElementById('progress-indicator'); // [NEW]
        const getFeedbackButton = document.getElementById('get-feedback-button');
        const resetButton = document.getElementById('reset-button'); // New reset button

        // Feedback Report Elements
        const feedbackScoreEl = document.getElementById('feedback-score');
        const feedbackSummaryEl = document.getElementById('feedback-summary');
        const feedbackChartCanvas = document.getElementById('feedback-radar-chart');
        const goodPointsList = document.getElementById('good-points-list');
        const improvementPointsList = document.getElementById('improvement-points-list');
        const actionPlanText = document.getElementById('action-plan-text');

        let selectedCourse = null;
        let originalChunks = [];
        let feedbackChart = null; // To hold the chart instance
        let loaderInterval = null; // [NEW] 로더 텍스트 순환용

        // --- Event Listeners ---
        textInput.addEventListener('input', () => {
            updateButtonState();
            updateCharCounter(); // [NEW]
        });
        errorClose.addEventListener('click', () => errorBanner.classList.add('hidden')); // [NEW]
        // [NEW] 분석 입력창에 대한 이벤트 위임
        analysisInputsContainer.addEventListener('input', updateProgressIndicator);

        courseOptions.forEach(option => {
            option.addEventListener('click', () => {
                courseOptions.forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                selectedCourse = option.dataset.course;
                updateButtonState();
            });
        });

        startSplitButton.addEventListener('click', handleStartSplit);
        getFeedbackButton.addEventListener('click', handleGetFeedback);
        resetButton.addEventListener('click', resetUI); // Add listener for reset button


        // --- Core Functions ---

        // --- [NEW] showError 함수 ---
        function showError(message) {
            errorMessage.textContent = safeHtml(message);
            errorBanner.classList.remove('hidden');
            window.scrollTo(0, 0); // 오류 메시지를 볼 수 있도록 상단으로 스크롤
        }

        // --- [NEW] updateCharCounter 함수 ---
        function updateCharCounter() {
            const length = textInput.value.length;
            charCounter.textContent = `${length} / 50자`;
            if (length >= 50) {
                charCounter.classList.add('sufficient');
            } else {
                charCounter.classList.remove('sufficient');
            }
        }

        // --- [NEW] updateProgressIndicator 함수 ---
        function updateProgressIndicator() {
            const allInputs = analysisInputsContainer.querySelectorAll('.analysis-input');
            const total = allInputs.length;
            if (total === 0) return;

            let completed = 0;
            allInputs.forEach(input => {
                if (input.value.trim().length > 0) {
                    completed++;
                }
            });
            progressIndicator.textContent = `${completed} / ${total} 항목 분석 완료`;
        }


        function updateButtonState() {
            startSplitButton.disabled = !(textInput.value.trim().length >= 50 && selectedCourse); // 50자 이상 조건
        }

        // --- [NEW] 동적 로더 제어 함수 ---
        function showDynamicLoader(messages = ["처리 중입니다..."]) {
            let messageIndex = 0;
            loaderText.textContent = messages[messageIndex];

            // Clear any existing interval
            if (loaderInterval) {
                clearInterval(loaderInterval);
            }

            // Cycle through messages
            loaderInterval = setInterval(() => {
                messageIndex = (messageIndex + 1) % messages.length;
                loaderText.textContent = messages[messageIndex];
            }, 2500); // 2.5초마다 텍스트 변경

            dynamicLoader.classList.remove('hidden');
            // 'main-card'에 'flex'가 없으므로 display:flex 대신 remove('hidden')만 사용합니다.
            // #dynamic-loader CSS에 display:flex가 없음을 확인.
            // 아, .main-card에 display:flex가 없군요. .hidden만 제어하면 됩니다.
        }

        function hideDynamicLoader() {
            if (loaderInterval) {
                clearInterval(loaderInterval);
            }
            loaderInterval = null;
            dynamicLoader.classList.add('hidden');
        }
        // --- [END] 동적 로더 제어 함수 ---


        async function handleStartSplit() {
            const text = textInput.value.trim();
             // 유효성 검사 강화
            if (text.length < 50) {
                 showError("분석할 텍스트를 50자 이상 입력하세요."); // [MODIFIED]
                 return;
            }
            if (!selectedCourse) {
                showError("훈련 코스를 선택해주세요."); // [MODIFIED]
                return;
            }

            startSplitButton.disabled = true;
            startSplitButton.textContent = 'AI가 쪼개는 중...';
            // --- [MODIFIED] 로더 로직 변경 ---
            inputSection.classList.add('hidden'); // 입력 섹션 숨김
            // analysisSkeleton.classList.remove('hidden'); // [DELETED]
            const splitMessages = [
                "AI가 텍스트를 분석 중입니다...",
                "최소 의미 단위로 쪼개고 있습니다...",
                "핵심 전략을 파악 중입니다..."
            ];
            showDynamicLoader(splitMessages); // [NEW]
            errorBanner.classList.add('hidden'); // 기존 오류 숨김

            try {
                const chunks = await callGeminiApi(SPLIT_PROMPT(text, selectedCourse));
                originalChunks = chunks;
                displayAnalysisInputs(chunks);
                analysisSection.classList.remove('hidden'); // 분석 섹션 표시
            } catch (error) {
                console.error('Error splitting text:', error);
                showError(`텍스트를 쪼개는 중 오류가 발생했습니다: ${error.message}`); // [MODIFIED]
                inputSection.classList.remove('hidden'); // 오류 시 입력 섹션 다시 표시
            } finally {
                startSplitButton.disabled = false;
                startSplitButton.textContent = '쪼개기 훈련 시작';
                // --- [MODIFIED] 로더 로직 변경 ---
                // analysisSkeleton.classList.add('hidden'); // [DELETED]
                hideDynamicLoader(); // [NEW]
            }
        }

        function displayAnalysisInputs(chunks) {
            analysisInputsContainer.innerHTML = '';
            chunks.forEach((chunk, index) => {
                const card = document.createElement('div');
                card.className = 'chunk-card';
                const safeChunk = chunk.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                card.innerHTML = `
                    <div class="original-text-container">
                        <h4>#${index + 1} 원본 의미 단위</h4>
                        <p class="original-text">${safeChunk}</p>
                    </div>
                    <div class="analysis-input-container">
                        <h4>나의 사고 과정 분석</h4>
                        <textarea class="analysis-input" data-index="${index}" placeholder="이 문장을 쓴 의도는 무엇인가?\n고객의 어떤 반박을 제거하려 했는가?\n어떤 심리학적 원리를 사용했는가?"></textarea>
                    </div>
                `;
                analysisInputsContainer.appendChild(card);
            });
            updateProgressIndicator(); // [NEW] 초기 진행률 설정 (0 / N)
        }

        async function handleGetFeedback() {
            const analysisTextareas = document.querySelectorAll('.analysis-input');
            const userAnalyses = [];
            let allFilled = true;

            analysisTextareas.forEach(textarea => {
                const analysisText = textarea.value.trim();
                textarea.classList.remove('invalid'); // [NEW] 초기화
                if (!analysisText) {
                    allFilled = false;
                    textarea.classList.add('invalid'); // [NEW] 빨간 테두리
                }
                userAnalyses.push({
                    original_chunk: originalChunks[textarea.dataset.index],
                    user_analysis: analysisText
                });
            });

            if (!allFilled) {
                showError('모든 사고 과정 분석을 입력해주세요. 누락된 항목이 표시됩니다.'); // [MODIFIED]
                return;
            }

            getFeedbackButton.disabled = true;
            getFeedbackButton.textContent = '리포트 생성 중...';
            // --- [MODIFIED] 로더 로직 변경 ---
            analysisSection.classList.add('hidden'); // 분석 섹션 숨김
            // feedbackSkeleton.classList.remove('hidden'); // [DELETED]
            const feedbackMessages = [
                "성장 리포트를 생성 중입니다...",
                "사고 과정을 정밀 채점 중입니다...",
                "S-Class 피드백을 구성하고 있습니다..."
            ];
            showDynamicLoader(feedbackMessages); // [NEW]
            errorBanner.classList.add('hidden'); // 기존 오류 숨김

            try {
                const feedback = await callGeminiApi(FEEDBACK_PROMPT(userAnalyses));
                displayFeedbackReport(feedback);
                feedbackReportSection.classList.remove('hidden'); // 리포트 섹션 표시
                 window.scrollTo(0, 0); // 페이지 상단으로 스크롤
            } catch (error) {
                console.error('Error getting feedback:', error);
                 showError(`피드백을 받는 중 오류가 발생했습니다: ${error.message}`); // [MODIFIED]
                 analysisSection.classList.remove('hidden'); // 오류 시 분석 섹션 다시 표시
            } finally {
                getFeedbackButton.disabled = false;
                getFeedbackButton.textContent = '분석 완료 & 성장 리포트 보기';
                // --- [MODIFIED] 로더 로직 변경 ---
                // feedbackSkeleton.classList.add('hidden'); // [DELETED]
                hideDynamicLoader(); // [NEW]
            }
        }

        // --- [NEW] Display Feedback Report ---
         function displayFeedbackReport(feedback) {
            if (typeof feedback!== 'object' || feedback === null) {
                console.error("Invalid feedback format:", feedback);
                // [MODIFIED] 오류 처리
                showError('AI로부터 유효한 JSON 피드백을 받지 못했습니다. 잠시 후 다시 시도해주세요.');
                analysisSection.classList.remove('hidden'); // 분석 섹션으로 복귀
                return;
            }

            const {
                score = 0,
                criteria_scores = { instinct: 0, rebuttal: 0, psychology: 0, customer_success: 0 },
                good_points = [],
                improvement_points = [],
                action_plan = '다음 훈련 목표를 설정하세요.'
             } = feedback;


            // 1. 점수 및 요약 표시
            let scoreClass = 'score-c'; // Default C (0-39)
            if (score >= 85) scoreClass = 'score-s';
            else if (score >= 60) scoreClass = 'score-a';
            else if (score >= 40) scoreClass = 'score-b';


            let summary = '아직 개선이 많이 필요합니다. 피드백을 통해 기본기를 다지세요.';
            if (score >= 85) summary = '훌륭합니다! S-Class 마케터의 사고방식이 보입니다.';
            else if (score >= 60) summary = '좋은 시도입니다. 핵심 원리를 거의 이해하고 있습니다.';
            else if (score >= 40) summary = '성장의 가능성이 보입니다. 피드백을 통해 핵심을 파악하세요.';


            feedbackScoreEl.textContent = `${score}점`;
            feedbackScoreEl.className = scoreClass; // 점수 색상 적용
            feedbackSummaryEl.textContent = safeHtml(summary);

             // 2. 레이더 차트 생성/업데이트
            renderRadarChart(criteria_scores);

            // 3. 상세 피드백 목록 표시 (마크다운 제거 확인)
            goodPointsList.innerHTML = good_points.map(p => `<li>${safeHtml(p)}</li>`).join('');
            improvementPointsList.innerHTML = improvement_points.map(p => `<li>${safeHtml(p)}</li>`).join('');


             // 4. 액션 플랜 표시
            actionPlanText.textContent = safeHtml(action_plan);

             // 5. 셀프 코칭 질문은 HTML에 고정되어 있음

        }

        // --- [NEW] Render Radar Chart ---
        function renderRadarChart(scores) {
            const ctx = feedbackChartCanvas.getContext('2d');
            const labels = ['본능 분석', '반박 제거', '심리학 원리', '고객 성공'];
            const data = [
                scores.instinct || 0,
                scores.rebuttal || 0,
                scores.psychology || 0,
                scores.customer_success || 0
            ];

            // 기존 차트가 있으면 파괴 후 다시 그림
             if (feedbackChart) {
                feedbackChart.destroy();
            }


            feedbackChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '쪼개기 역량 점수',
                        data: data,
                        fill: true,
                        backgroundColor: 'rgba(74, 128, 243, 0.2)', // 파랑 투명
                        borderColor: 'rgb(74, 128, 243)', // 파랑
                        pointBackgroundColor: 'rgb(74, 128, 243)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgb(77, 128, 243)'
                    }]
                },
                options: {
                    elements: {
                        line: {
                            borderWidth: 3
                        }
                    },
                     scale: {
                         r: {
                             angleLines: {
                                display: false
                             },
                             suggestedMin: 0,
                             suggestedMax: 100,
                             ticks: {
                                 stepSize: 20 // 0, 20, 40, 60, 80, 100
                            }
                         }
                    },
                     plugins: {
                        legend: {
                             display: false // 범례 숨김
                        }
                    }
                }
            });
        }


        // --- [NEW] Reset UI Function ---
         function resetUI() {
             // 1. 섹션 표시 상태 초기화
            inputSection.classList.remove('hidden');
            analysisSection.classList.add('hidden');
            feedbackReportSection.classList.add('hidden');
            errorBanner.classList.add('hidden'); // [NEW]
            // --- [DELETED] 스켈레톤 숨김 ---
            // analysisSkeleton.classList.add('hidden');
            // feedbackSkeleton.classList.add('hidden');
            hideDynamicLoader(); // [NEW]

             // 2. 입력값 초기화
            textInput.value = '';
            courseOptions.forEach(o => o.classList.remove('selected'));
            selectedCourse = null;
            originalChunks = [];
            analysisInputsContainer.innerHTML = ''; // 분석 카드 제거
            updateCharCounter(); // [NEW]
            progressIndicator.textContent = ''; // [NEW]

             // 3. 버튼 상태 초기화
            startSplitButton.disabled = true;

             // 4. 차트 파괴 (다시 그릴 때 생성)
             if (feedbackChart) {
                 feedbackChart.destroy();
                 feedbackChart = null;
             }
              window.scrollTo(0, 0); // 페이지 상단으로 스크롤
         }


        // --- [START] REAL API CALL LOGIC ---
        // (Includes exponential backoff and JSON parsing)
        async function callGeminiApi(prompt) {
            console.log("Sending prompt to API:", prompt);
             let retries = 0;
             const maxRetries = 3;
             const baseDelay = 1000; // 1 second

             while(retries < maxRetries) {
                 try {
                     const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: {
                                responseMimeType: "application/json", // Expect JSON response
                            },
                            safetySettings: [
                                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                                // --- [START] 400 오류 수정 (이전 수정사항) ---
                                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" } // "DANGS" -> "DANGEROUS"
                                // --- [END] 400 오류 수정 (이전 수정사항) ---
                            ]
                        })
                    });

                    if (!response.ok) {
                         if (response.status === 429 || response.status >= 500) {
                             retries++;
                             if (retries >= maxRetries) throw new Error(`API 호출이 ${maxRetries}번의 재시도 후에도 실패했습니다 (Status: ${response.status}).`);
                             const delay = baseDelay * Math.pow(2, retries);
                             console.warn(`API call failed with status ${response.status}. Retrying in ${delay}ms... (${retries}/${maxRetries})`);
                             await new Promise(resolve => setTimeout(resolve, delay));
                             continue;
                         } else {
                            const errorBody = await response.text();
                            console.error("API Error Body:", errorBody);
                            throw new Error(`API 호출 실패: ${response.status} ${response.statusText}`);
                         }
                    }

                    const data = await response.json();

                    // 응답 구조 유효성 검사 강화
                     if (!data.candidates || data.candidates.length === 0 ||!data.candidates[0].content ||!data.candidates[0].content.parts || data.candidates[0].content.parts.length === 0) {
                        if (data.candidates && data.candidates.length > 0 && data.candidates[0].finishReason === 'SAFETY') {
                            throw new Error("AI가 안전상의 이유로 응답을 거부했습니다.");
                        }
                        if (data.promptFeedback && data.promptFeedback.blockReason) {
                             throw new Error(`API 요청이 차단되었습니다: ${data.promptFeedback.blockReason}`);
                        }
                         console.error("Invalid API Response Structure:", data);
                         throw new Error("AI로부터 유효한 응답 구조를 받지 못했습니다.");
                    }


                    const jsonString = data.candidates[0].content.parts[0].text;

                    try {
                        // JSON 파싱 시도
                        const parsedResult = JSON.parse(jsonString);
                        // SPLIT_PROMPT는 배열을 반환해야 함
                         if (prompt.includes('Jjokegi Theory') && !Array.isArray(parsedResult)) {
                             console.error("Split prompt did not return an array:", parsedResult);
                             throw new Error("AI가 텍스트 쪼개기 결과를 배열 형식으로 반환하지 않았습니다.");
                         }
                         // FEEDBACK_PROMPT는 객체를 반환해야 함
                         if (!prompt.includes('Jjokegi Theory') && (typeof parsedResult !== 'object' || parsedResult === null || Array.isArray(parsedResult))) {
                             console.error("Feedback prompt did not return an object:", parsedResult);
                             throw new Error("AI가 피드백 결과를 객체 형식으로 반환하지 않았습니다.");
                         }
                        return parsedResult;
                    } catch (parseError) {
                        console.error("Failed to parse JSON response:", jsonString, parseError);
                        throw new Error("AI가 유효한 JSON 형식을 반환하지 않았습니다.");
                    }

                } catch (error) {
                    console.error("API Error during fetch or processing:", error);
                     if (retries >= maxRetries) {
                         throw error; // 최종 재시도 후에도 실패하면 오류 던짐
                     }
                     // 네트워크 오류 등 재시도 가능한 오류 처리
                     // --- [START] 재시도 로직 수정 (이전 수정사항) ---
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                     // --- [END] 재시도 로직 수정 (이전 수정사항) ---
                        retries++;
                        const delay = baseDelay * Math.pow(2, retries);
                        console.warn(`API/Network error. Retrying in ${delay}ms... (${retries}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // 다음 재시도
                    } else {
                        // JSON 파싱 오류, 400 오류 등 재시도 불가능한 오류는 즉시 던짐
                        throw error;
                    }
                }
             }
              // 이론적으로는 여기에 도달하지 않아야 함
             throw new Error(`API 호출이 ${maxRetries}번의 재시도 후에도 실패했습니다.`);
        }
        // --- [END] REAL API CALL LOGIC ---

        // Helper function for safe HTML display
        function safeHtml(text) {
          return text ? text.replace(/</g, "&lt;").replace(/>/g, "&gt;") : '';
        }

        // 초기 로드 시 카운터 상태 업데이트
        updateCharCounter();
    </script>
</body>
</html>